
/*@

java.util.javaspec

fixpoint pair<t1, t2> update_fst<t1, t2>(t1 v, pair<t1, t2> s) {
    switch(s) {
        case pair(a, b): return pair(v, b);
    }
}

fixpoint pair<t1, t2> update_snd<t1, t2>(t2 v, pair<t1, t2> s) {
    switch(s) {
        case pair(a, b): return pair(a, v);
    }
}

fixpoint boolean distinct<t>(list<t> xs) {
    switch (xs) {
        case nil: return true;
        case cons(x, xs0): return !mem(x, xs0) && distinct(xs0);
    }
}

lemma_auto(distinct(xs)) void distinct_tail<t>(list<t> xs);
    requires distinct(xs) == true;
    ensures distinct(tail(xs)) == true;

lemma_auto(fst_list(xs)) void equal_length<t1, t2>(list<pair<t1, t2> > xs);
    requires true;
    ensures length(xs) == length(fst_list(xs)) && length(xs) == length(snd_list(xs));

lemma_auto(length(remove(x, xs))) void length_remove<t>(t x, list<t> xs);
    requires true;
    ensures length(xs) - 1 <= length(remove(x, xs)) && length(remove(x, xs)) <= length(xs);

fixpoint t2 in_map<t1, t2>(t1 key, list<pair<t1, t2> > map) {
    switch(map) {
        case nil: return default_value<t2>;
        case cons(m, m0): return fst(m) == key ? snd(m) : in_map(key, m0);
    }
}

fixpoint boolean contains_key<t1, t2>(t1 key, list<pair<t1, t2> > map) {
    switch(map) {
        case nil: return false;
        case cons(m, m0): return fst(m) == key ? true : contains_key(key, m0); 
    }
}

fixpoint list<pair<t1, t2> > update_value<t1, t2>(t1 key, t2 value, list<pair<t1, t2> > map) {
    switch(map) {
        case nil: return nil;
        case cons(m, m0): return fst(m) == key ? cons(update_snd(value, m), m0) : cons(m, update_value(key, value, m0));
    }
}

fixpoint list<pair<t1, t2> > remove_pair<t1, t2>(t1 key, list<pair<t1, t2> > map) {
    switch(map) {
        case nil: return nil;
        case cons(m, m0): return fst(m) == key ? m0 : cons(m, remove_pair(key, m0));
    }
}

fixpoint list<pair<t1, t2> > remove_pair_nth<t1, t2>(int n, list<pair<t1, t2> > xs) {
    switch(xs) {
        case nil: return nil;
        case cons(h, t): return n == 0 ? t : cons(h, remove_pair_nth(n - 1, t));
    }
}

fixpoint list<t1> fst_list<t1, t2>(list<pair<t1, t2> > s) {
    switch(s) {
        case nil: return nil;
        case cons(x, xs0): return cons(fst(x), fst_list(xs0));
    }
}

fixpoint list<t2> snd_list<t1, t2>(list<pair<t1, t2> > s) {
    switch(s) {
        case nil: return nil;
        case cons(x, xs0): return cons(snd(x), snd_list(xs0));
    }
}

fixpoint boolean subset<t>(list<t> l1, list<t> l2) {
    switch(l2) {
        case nil: return true;
        case cons(m, m0): return mem(m, l1) == true ? subset(l1, m0) : false; 
    }
}

fixpoint boolean not_null(list<Object> xs) {
    switch (xs) {
        case nil: return true;
        case cons(x, xs0): return x != null && not_null(xs0);
    }
}

fixpoint option<t> seq_of_list<t>(list<t> xs, int n) {
    switch (xs) {
        case nil: return none;
        case cons(x, xs0): return n == 0 ? some(x) : seq_of_list(xs0, n - 1);
    }
}

lemma_auto void seq_of_list_length<t>(list<t> xs, int i);
    requires 0 <= i;
    ensures true == ((seq_of_list(xs, i) == none) == (length(xs) <= i));

lemma_auto void seq_of_list_nth<t>(list<t> xs, int i);
    requires seq_of_list(xs, i) != none;
    ensures seq_of_list(xs, i) == some(nth(i, xs));

@*/
